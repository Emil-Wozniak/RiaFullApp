package org.ria.ifzz.RiaApp.service;

import org.ria.ifzz.RiaApp.domain.Backlog;
import org.ria.ifzz.RiaApp.domain.ControlCurve;
import org.ria.ifzz.RiaApp.domain.FileEntity;
import org.ria.ifzz.RiaApp.domain.Result;
import org.ria.ifzz.RiaApp.exception.CurveException;
import org.ria.ifzz.RiaApp.repository.ControlCurveRepository;
import org.ria.ifzz.RiaApp.repository.ResultRepository;
import org.ria.ifzz.RiaApp.utils.CountResultUtil;
import org.ria.ifzz.RiaApp.utils.CustomFileReader;
import org.ria.ifzz.RiaApp.utils.FileUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import javax.validation.constraints.NotNull;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import static org.ria.ifzz.RiaApp.domain.HormonesPattern.CORTISOL_PATTERN;

@RestController
public class ResultService {

    @Autowired
    FileEntityService fileEntityService;

    private final CustomFileReader customFileReader;
    private final CountResultUtil countResultUtil;
    private final FileUtils fileUtils;
    private final ControlCurveRepository controlCurveRepository;
    private final ControlCurveService controlCurveService;

    public ResultService(CustomFileReader customFileReader, CountResultUtil countResultUtil, FileUtils fileUtils, ControlCurveRepository controlCurveRepository, ControlCurveService controlCurveService) {
        this.customFileReader = customFileReader;
        this.countResultUtil = countResultUtil;
        this.fileUtils = fileUtils;
        this.controlCurveRepository = controlCurveRepository;
        this.controlCurveService = controlCurveService;
    }

    /**
     * takes file store in local disc space
     *
     * @param file uploaded file
     * @return expected List of Strings
     * @throws IOException
     */
    public List<String> getFileData(MultipartFile file) throws IOException {
        System.out.println(customFileReader.getUploadComment());

        List<String> fileLineList = customFileReader.readStoredTxtFile(file);
        List<String> expectedLineList = customFileReader.removeUnnecessaryLineFromListedFile(fileLineList);
        System.out.println("File has: " + expectedLineList.size() + " lines");
        return expectedLineList;
    }

    /**
     * takes fileName of upload file and set specific id for each entities
     * reads given Strings List and create Result entity for each lines of given,
     *
     * @param list pre-cleaned list
     * @param file
     * @return Result entities
     */
    public List<Result> setResultFromColumnsLength(List<String> list, @NotNull MultipartFile file, Backlog backlog, Result result) {
        int i = 0;
        List<Result> results = new ArrayList<>();
        for (String line : list) {
            if (line.startsWith(" \tUnk")) {
                int a = i++;
                System.out.println(a + " > " + line);
                result = new Result();
                result.setFileName("row_" + list.indexOf(line) + "_" + fileUtils.setFileName(file));
                result.setBacklog(backlog);
                results.add(result);
            }
        }
        return results;
    }

    /**
     * find Result entity in database by {@code}fileName_index,
     * which is created by file's fileName + _ + index, and
     * then assign results from "CCMP" table
     *
     * @param list generated by upload file
     */
    public List<Result> assignDataToResult(List<String> list, FileEntity fileEntity, List<Result> results) {

        String fileId = fileEntity.getDataId();

        List<Result> resultsWithData = new ArrayList<>();
        //Assign CCMP to Result
        for (int i = 24; i < list.size() - 1; i++) {
            List CCMP = customFileReader.getMatchingStrings(list, 3);

            Result result = results.get(i);
            String ccmpString = CCMP.get(i).toString();
            Double ccmpInteger = Double.parseDouble(ccmpString);
            result.setCcpm(ccmpInteger);
            System.out.println(" \tResult CCMP value: " + result.getCcpm() + " in position " + i);
            resultsWithData.add(result);
        }

        //Assign position to Result
        for (int i = 24; i < list.size() - 1; i++) {
            List position = customFileReader.getMatchingStrings(list, 2);
            Result result = results.get(i);
            result.setPosition(position.get(i).toString());
            resultsWithData.add(result);
        }

        //Assign samples to Result
        for (int i = 24; i < list.size() - 1; i++) {
            List Samples = customFileReader.getMatchingStrings(list, 1);
            Result result = results.get(i);
            result.setDataId(fileId);

            String cleanedSamples = Samples.get(i).toString();
            String replacedSamples = cleanedSamples.replace("Unk_", "");
            Integer samplesInt = Integer.parseInt(replacedSamples);
            result.setSamples(samplesInt);
            System.out.println(" \tResult samples value: " + result.getSamples());
            resultsWithData.add(result);
        }
        return resultsWithData;
    }

    public List<Result> assignNgPerMl(@NotNull MultipartFile file, List<String> list, List<ControlCurve> controlCurveList, List<Result> results) {

        Result result = new Result();
        List<Result> countedResults = new ArrayList<>();
        List<Double> curve = new ArrayList<>();
        ControlCurve controlCurve;

        // get standard pattern
        countResultUtil.logDose(CORTISOL_PATTERN);

        try {
            for (int i = 0; i < 24; i++) {
                controlCurve = controlCurveList.get(i);
                double point = controlCurve.getCcpm();
                System.out.println(point);
                curve.add(point);
            }
        } catch (Exception exception) {
            throw new CurveException("\nFile " + curve.toString() + " doesn't have a proper size; \nIt must contain at least 24 line for curve and 2 line of results;\n" + exception.getCause());
        }

        countResultUtil.setControlCurveCMP(curve);
        countResultUtil.setStandardsCMP(curve);
        countResultUtil.bindingPercent();
        countResultUtil.logarithmRealZero();
        countResultUtil.countRegressionParameterB();
        countResultUtil.countRegressionParameterA();

        List<Double> countedList = new ArrayList<>();
        for (int i = 25; i < list.size(); i++) {
            result = results.get(i);
            double point = result.getCcpm();
            double counted = countResultUtil.countResult(point);
            System.out.println("nr: " + i + " counted: " + counted);
            countedList.add(counted);
            if (Double.isNaN(counted)) {
                counted = 0.0;
            }
            result.setNg(counted);
            countedResults.add(result);
        }

        return countedResults;
    }

    public List<Result> setDataToResult(@NotNull MultipartFile file, List<String> list, Backlog backlog, FileEntity fileEntity) {
        Result newResult = new Result();
        List<Result> results = setResultFromColumnsLength(list, file, backlog, newResult);
        List<Result> resultsWithData = assignDataToResult(list, fileEntity, results);
        List<ControlCurve> controlCurveList = controlCurveService.setControlCurveFromColumnsLength(list, file, backlog);
        List<ControlCurve> controlCurveListWithData = controlCurveService.setDataToControlCurve(list, file, fileEntity, controlCurveList);
        controlCurveRepository.saveAll(controlCurveListWithData);
        List<Result> resultListWithNg = assignNgPerMl(file, list, controlCurveListWithData, resultsWithData);

        return resultListWithNg;
    }
}

